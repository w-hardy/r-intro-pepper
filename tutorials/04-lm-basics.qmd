---
title: "Linear models: a minimal example"
---

Linear models describe how a numeric response changes with one or more predictors.  
In this chapter you will:

1. Fit a linear model with `lm()`
2. Tidy coefficient estimates for interpretation
3. Check model diagnostics and make predictions

:::{.callout-note}
This section assumes:

* you have loaded `dplyr`, `ggplot2`, and `broom`
* your response variable is numeric and roughly continuous
* you have inspected the data for missing values or obvious entry errors
:::

We continue using the `penguins` dataset to predict bill length.

```{r}
#| message: false
library(dplyr)   # Data manipulation
library(ggplot2) # Visualisation
library(broom)   # Model tidying

penguins |>
  select(species, bill_len, bill_dep, flipper_len, body_mass, sex) |>
  head()
```

---

## Fit a linear model

Use `lm()` with a formula of the form `response ~ predictor1 + predictor2` to estimate how a numeric outcome changes with one or more predictors.  
For example, we can model penguin bill length as a function of bill depth.

::: {.panel-tabset}

### Example

```{r}
fit_simple <- lm(bill_len ~ bill_dep, data = penguins)
fit_simple
```

This output gives the intercept and slope estimates for the linear relationship between `bill_len` and `bill_dep`.

### Exercise

Extend the model to also include `species` as a categorical predictor. Replace the blanks with the appropriate code.

```{r}
#| eval: false

fit_species <- lm(bill_len ~ bill_dep + ____, data = ____)
fit_species
```

:::{.callout-tip}
`lm()` automatically creates indicator variables for factors such as `species`.
:::

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

fit_species <- lm(bill_len ~ bill_dep + species, data = penguins)
fit_species
```

:::

## Include interaction terms

Interactions let the effect of one predictor change depending on another predictorâ€™s value.

::: {.panel-tabset}

### Example

Fit a model with an interaction between bill depth and species.

```{r}
fit_interaction <- lm(bill_len ~ bill_dep * species, data = penguins)
tidy(fit_interaction)
```

### Exercise

Fit a model that allows the effect of bill depth to differ by sex. Replace the blanks.

```{r}
#| eval: false

fit_sex <- lm(bill_len ~ bill_dep * ____, data = ____)
tidy(fit_sex)
```

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

fit_sex <- lm(bill_len ~ bill_dep * sex, data = penguins)
tidy(fit_sex)
```

:::

---

## Interpret coefficients

`broom::tidy()` converts model output into a tidy tibble that is easy to read and combine with other results.  
Each coefficient represents the expected change in bill length for a one-unit change in that predictor, holding all others constant.

::: {.panel-tabset}

### Example

Obtain coefficient estimates with standard errors and p-values.

```{r}
tidy(fit_species)
```

### Exercise

Add 95% confidence intervals to the tidy output. Replace the blanks with the correct argument names.

```{r}
#| eval: false

tidy(fit_species, conf.int = ____, conf.level = ____)
```

:::{.callout-note}
Confidence intervals show a range of plausible values for each coefficient.
:::

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

tidy(fit_species, conf.int = TRUE, conf.level = 0.95)
```

:::

---

## Assess model fit and compare models

Use `glance()` to summarise overall model fit for linear models.  
Key statistics include:

* **`r.squared` and `adj.r.squared`**: proportion of variance explained (adjusted accounts for extra predictors).
* **`sigma`**: residual standard error (lower values indicate tighter residuals).
* **`AIC` and `BIC`**: information criteria for comparing models (lower is better).

When comparing **nested** models (one model is a special case of the other), use `anova()` with both models to test whether the larger model improves fit.

::: {.panel-tabset}

### Example

Compare fit summaries for two models and look at information criteria.

```{r}
bind_rows(
  glance(fit_simple) |> mutate(model = "bill_dep"),
  glance(fit_species) |> mutate(model = "bill_dep + species")
) |>
  select(model, r.squared, adj.r.squared, sigma, AIC, BIC)
```

Test whether adding `species` improves the fit relative to the simpler model.

```{r}
anova(fit_simple, fit_species)
```

### Exercise

Using the same two models, extract only `AIC` and `BIC` for comparison. Replace the blanks.

```{r}
#| eval: false

bind_rows(
  glance(____) |> mutate(model = "bill_dep"),
  glance(____) |> mutate(model = "bill_dep + species")
) |>
  select(model, AIC, BIC)
```

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

bind_rows(
  glance(fit_simple) |> mutate(model = "bill_dep"),
  glance(fit_species) |> mutate(model = "bill_dep + species")
) |>
  select(model, AIC, BIC)
```

:::

---

## Check diagnostics and predict

Use `augment()` for row-level diagnostics.  
Residuals should scatter randomly around zero; systematic patterns may indicate model misspecification.  
Predictions require a tibble of new values using the same variable names as in the model.

::: {.panel-tabset}

### Example

We first examine model diagnostics.

```{r}
augmented <- augment(fit_species)

ggplot(augmented, aes(x = .fitted, y = .resid, colour = species)) +
  geom_point() +
  geom_hline(yintercept = 0, linewidth = 0.3) +
  labs(x = "Fitted bill length", y = "Residuals") +
  theme_minimal()
```

Summarise overall model fit.

```{r}
glance(fit_species)
```

We can also use `predict()` to generate fitted values for the training data or new data.  
Here we predict bill length for the first three penguins in the dataset.

```{r}
predict(fit_species, newdata = penguins |> head(3))
```

`predict()` returns a numeric vector of fitted values corresponding to the supplied rows.

### Exercise

Create predicted bill lengths for new penguins with specified bill depth and species.
Replace the blanks with the correct column names or objects.

```{r}
#| eval: false

# tibble() creates a small data frame of new values
new_penguins <- tibble(
  bill_dep = c(17, 19),
  species = c("Adelie", "Gentoo")
)

predict(____, newdata = ____)
```

:::{.callout-warning}
Always check that your new data use the same variable names and factor levels as the original training data.
:::

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

new_penguins <- tibble(
  bill_dep = c(17, 19),
  species = c("Adelie", "Gentoo")
)

predict(fit_species, newdata = new_penguins)
```

:::

---

## Assumption checks and common violations

Linear models rely on several assumptions; violations can lead to biased estimates or unreliable inference.  
Use the diagnostic columns from `augment()` to look for these issues.

**Key assumptions and what they mean:**

* **Linearity**: the mean response changes linearly with each predictor (or with the linear predictor after any transformations).
* **Independence**: observations are independent, so residuals are not correlated across rows.
* **Constant variance (homoskedasticity)**: residual spread is roughly the same across fitted values.
* **Normal residuals**: residuals are approximately normal, which matters most for small-sample inference.
* **No extreme influence**: a small number of observations should not dominate the fitted line.

::: {.panel-tabset}

### Example

Check linearity and equal variance with a residuals-versus-fitted plot, assess independence with residuals by row order, and check normality with a QQ plot.

```{r}
augmented <- augment(fit_species) |>
  mutate(row_id = row_number())

# Linearity and equal variance (no patterns or fan shapes)
ggplot(augmented, aes(x = .fitted, y = .resid)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linewidth = 0.3) +
  labs(x = "Fitted bill length", y = "Residuals") +
  theme_minimal()

# Independence check (no runs or trends across row order)
ggplot(augmented, aes(x = row_id, y = .resid)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linewidth = 0.3) +
  labs(x = "Row order", y = "Residuals") +
  theme_minimal()

# Normality check (points should track the line)
ggplot(augmented, aes(sample = .std.resid)) +
  stat_qq() +
  stat_qq_line() +
  labs(x = "Theoretical quantiles", y = "Standardised residuals") +
  theme_minimal()
```

### Exercise

Use the same `augmented` tibble to flag potentially influential observations by sorting on Cook's distance. Replace the blanks.

```{r}
#| eval: false

augmented |>
  arrange(desc(____)) |>
  select(.cooksd, .fitted, .resid) |>
  head(5)
```

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

augmented |>
  arrange(desc(.cooksd)) |>
  select(.cooksd, .fitted, .resid) |>
  head(5)
```

:::

:::{.callout-warning}
Examples of assumption violations to watch for:

* **Curvature** in the residual plot (suggests a missing nonlinear term).
* **Funnel or fan shapes** in residual spread (heteroskedasticity).
* **Heavy tails or S-shaped QQ plot** (non-normal residuals).
* **Large Cook's distance values** (influential observations).
:::

## Summarise residual variation

Residual summaries quantify how well the model captures the observed data.

::: {.panel-tabset}

### Example

Compute the mean and standard deviation of residuals from `fit_species`.

```{r}
augmented <- augment(fit_species)

augmented |>
  summarise(
    mean_resid = mean(.resid),
    sd_resid = sd(.resid)
  )
```

### Exercise

Using the same `augmented` tibble, calculate the mean absolute residual. Fill in the blanks.

```{r}
#| eval: false

augmented |>
  summarise(mean_abs_resid = mean(abs(___), na.rm = TRUE))
```

### Solution

```{r}
#| code-fold: true
#| code-summary: "Show solution"

augmented |>
  summarise(mean_abs_resid = mean(abs(.resid), na.rm = TRUE))
```

:::

---

## Next steps

You now know how to:

* fit a linear model with `lm()`
* interpret coefficients using `broom::tidy()`
* check assumptions with `augment()` and `glance()`
* generate predictions with `predict()`

Next, experiment with interaction terms (e.g., `bill_dep * species`) or try using another numeric response such as `body_mass`.
